% Get TMS position and angle positions coordinates for simNIBS simulation.
% The ouput is the values for 
%     simNIBS GUI.app: "Add TMS Poslist"->Add Position -> Position -> "Position" (TMS_pos) and "Direction Reference" (each column of angle_pos).
%     run_simnibs (matlab command): see run_simulation.m for example use.
%
% Only TMS position within median saggital plane is supported.
% inputs
%   eeg_cap_file (char): subject's /eeg_positions/EEG10-10_UI_Jurak_2007.csv file path
%           [subname].msh, m2m_[subname] directory etc. generated by "headreco all"
%   pos_from_Iz (positive number): TMS position defined as the distance from Iz in skull plane (mm)
%   TMS_angles(1xn matrix): angle (rad) of the TMS handle (0: towards Iz, increase with anticlockwise rotation)
%
% outputs
%   TMS_pos(3x1 matrix): TMS position coordinates in simNIBS coordinates
%   angle_pos (3xn matrix): angle definition coordinates each column
%                           corresponds to each values of TMS_angles.
%
% Programmed by M.Takemi at Aug 9th 2022
% Modified by S.Hirose at Aug 9th 2022

function [TMS_pos,angle_pos] = get_TMS_pos(eeg_cap_file,pos_from_Iz,TMS_angles)


%% load EEG position, and get Iz,Nz, and Cz coordinates in ORIGINAL COORDINATES; oc


% load EEG position file
opts = delimitedTextImportOptions("NumVariables", 5);
opts.DataLines = [1, Inf];
opts.Delimiter = ",";
opts.VariableNames = ["Category", "X", "Y", "Z", "Name"];
opts.VariableTypes = ["categorical", "double", "double", "double", "string"];
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";
EEGpos = readtable(eeg_cap_file,opts);

Iz_oc = table2array(EEGpos(find(strcmp(EEGpos.Name,"Iz"),1),2:4))';
Nz_oc = table2array(EEGpos(find(strcmp(EEGpos.Name,"Nz"),1),2:4))';
Cz_oc = table2array(EEGpos(find(strcmp(EEGpos.Name,"Cz"),1),2:4))';

%% transform to coordinates with origin of Iz, x axis parallel to Iz-Nz, Cz is in x-y plane (in MEDIAN SAGGITAL COORDINATES; mc)

    % parallel displacement to coordinates with origin of Iz (ORIGIN IZ COORDINATES; ic)
    Iz_ic = [0 0 0]';
    Nz_ic =  Nz_oc - Iz_oc;
    Cz_ic =  Cz_oc - Iz_oc;

    % find fundamental unit vectors of MEDIAN SAGGITAL COORDINATES in IZ ORIGIN COORDINATES
    x_fuv_mc_ic = (Nz_ic - Iz_ic)./norm(Nz_ic - Iz_ic);
    cz_univec = (Cz_ic - Iz_ic)./norm(Cz_ic - Iz_ic);
    y_fv_mc_ic = cz_univec - dot(cz_univec,x_fuv_mc_ic)*x_fuv_mc_ic; % orthogonalize
    y_fuv_mc_ic = y_fv_mc_ic./norm(y_fv_mc_ic); % norm = 1
    z_fuv_mc_ic = cross(x_fuv_mc_ic,y_fv_mc_ic);

    % linear transformation orthogonal matrix IZ ORIGIN COORDINATES -> MEDIAN SAGGITAL COORDINATES
    transmat = [x_fuv_mc_ic y_fuv_mc_ic z_fuv_mc_ic]';
    
    % coordinates with origin of Iz
    Iz_mc = transmat*Iz_ic;
    Nz_mc = transmat*Nz_ic;
    Cz_mc = transmat*Cz_ic;

%% calculate center and radius of the circle
% https://mathworld.wolfram.com/Circle.html eqs(27)-(34)
dot_Iz = dot(Iz_mc,Iz_mc);
dot_Nz = dot(Nz_mc,Nz_mc);
dot_Cz = dot(Cz_mc,Cz_mc);

a= det([[Iz_mc(1:2)';Nz_mc(1:2)';Cz_mc(1:2)'] ones(3,1)]);
d= -det([[dot_Iz;dot_Nz;dot_Cz],[Iz_mc(2);Nz_mc(2);Cz_mc(2)],ones(3,1)]);
e= det([[dot_Iz;dot_Nz;dot_Cz],[Iz_mc(1);Nz_mc(1);Cz_mc(1)],ones(3,1)]);
f= -det([[dot_Iz;dot_Nz;dot_Cz],[Iz_mc(1:2)';Nz_mc(1:2)';Cz_mc(1:2)']]);

radius = sqrt((d^2+e^2)/(4*a^2)-f/a);
C_mc = [-d/(2*a);-e/(2*a);0];

%% find the point pos_from_Iz (mm) above the Iz (P) in MEDIAN SAGGITAL COORDINATES
% P_cc: C (center of the circle) origin coordinates
cos_a = cos(pos_from_Iz/radius);
sin_a = sin(pos_from_Iz/radius);
cos_b = - C_mc(1)/radius; % e.g. Iz_cc(1)
sin_b = - C_mc(2)/radius; % e.g. Iz_cc(2)
P_cc = [(cos_a*cos_b+sin_a*sin_b)*radius;
        (sin_a*cos_b-cos_a*sin_b)*radius;
        0];

%% transform P_cc to ORIGINAL COORDINATES
P_mc = P_cc+C_mc; % parallel displacement
P_ic = transmat'*P_mc; % linear transformation [note: transmat'=inv(transmat)]
P_oc = P_ic+Iz_oc; % parallel displacement
TMS_pos=P_oc;
%% angle (0 = towards Iz)
% fundamental unit vectors of COORDINATES IN THE TANGENITAL SURFACE OF THE skull SPHERE (tc) in MEDIAN SAGGITAL COORDINATES
x_fuv_tc_mc = [-P_cc(2);P_cc(1);0]/norm(P_cc);
y_fuv_tc_mc = [0;0;1];
% linear transformation
x_fuv_tc_oc = transmat'*x_fuv_tc_mc;
y_fuv_tc_oc = transmat'*y_fuv_tc_mc;

% coil position for defined angle
angle_pos= repmat(P_oc,1,length(TMS_angles))+(x_fuv_tc_oc*cos(TMS_angles)+y_fuv_tc_oc*sin(TMS_angles))*10;

